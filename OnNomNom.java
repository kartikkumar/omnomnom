import lejos.nxt.Motor;import lejos.util.Stopwatch;import lejos.robotics.navigation.DifferentialPilot;import java.util.Random;import lejos.robotics.localization.OdometryPoseProvider;import lejos.robotics.navigation.Pose;import lejos.nxt.LightSensor;import lejos.nxt.UltrasonicSensor;import lejos.nxt.SensorPort;import lejos.util.Delay;import lejos.robotics.navigation.Navigator;import lejos.nxt.Sound;import lejos.robotics.navigation.Waypoint;public class OnNomNom{ DifferentialPilot pilot; public void go( int maximumTime, int returnHomeTime, int returnHomeObstacleTime, int delay, boolean returnHomeBlind, int turnInterval, float initialHeading, float ultrasonicSensorOffsetX, float ultrasonicSensorOffsetY, int travelSpeed, double minimumDistance, double xMinimum, double xMaximum, double yMinimum, double yMaximum, double boundsTolerance, int perimeterLightLimit ) { Random random = new Random( ); LightSensor lightSensor = new LightSensor( SensorPort.S4 ); UltrasonicSensor sonicSensor = new UltrasonicSensor( SensorPort.S2 ); OdometryPoseProvider poseProvider = new OdometryPoseProvider( pilot ); Pose pose = new Pose( ultrasonicSensorOffsetX, ultrasonicSensorOffsetY, initialHeading ); poseProvider.setPose( pose ); Navigator navigator = new Navigator( pilot, poseProvider ); pilot.setTravelSpeed( travelSpeed ); Stopwatch stopwatch = new Stopwatch( ); Stopwatch turnTimer = new Stopwatch( ); pilot.forward( ); while( true ) { pose = poseProvider.getPose( ); if ( stopwatch.elapsed( ) > maximumTime ) { pilot.stop( ); break; } if ( sonicSensor.getDistance( ) < minimumDistance ) { pilot.rotate( ( random.nextBoolean( ) ? 1 : -1 ) * 90 ); pilot.forward( ); } if ( turnTimer.elapsed( ) > turnInterval ) { pilot.rotate( ( random.nextBoolean( ) ? 1 : -1 ) * 90 ); pilot.forward( ); turnTimer.reset( ); } if ( pose.getX( ) > ( xMaximum - boundsTolerance ) || pose.getX( ) < ( xMinimum + boundsTolerance ) || pose.getY( ) > ( yMaximum - boundsTolerance ) || pose.getY( ) < ( yMinimum + boundsTolerance ) ) { pilot.rotate( 180 ); Delay.msDelay( delay ); pilot.forward( ); Delay.msDelay( delay ); } if ( lightSensor.getLightValue( ) < perimeterLightLimit ) { pilot.rotate( 180 ); Delay.msDelay( delay ); pilot.forward( ); Delay.msDelay( delay ); } if ( stopwatch.elapsed( ) > returnHomeTime ) { pilot.stop( ); System.out.println("[Heading home!]"); Delay.msDelay( delay ); Sound.beep( ); Sound.beep( ); Sound.beep( ); Sound.beep( ); break; } } pose = poseProvider.getPose( ); if ( returnHomeBlind ) { navigator.goTo( new Waypoint( 0, 0 ) ); navigator.waitForStop( ); System.out.println("[I'm home!]"); Delay.msDelay( delay ); Sound.beepSequence( ); Sound.beepSequence( ); Sound.beepSequence( ); } else { Stopwatch homeTimer = new Stopwatch( ); pilot.stop( ); while ( Math.abs( pose.getX( ) ) > 0 || Math.abs( pose.getY( ) ) > 0 ) { double currentHeading = pose.getHeading( ); double homeHeading = Math.atan2( pose.getY( ), pose.getX( ) ); Delay.msDelay( delay ); pilot.rotate( currentHeading - homeHeading ); pilot.forward( ); if ( sonicSensor.getDistance( ) < minimumDistance ) { pilot.rotate( ( random.nextBoolean( ) ? 1 : -1 ) * 90 ); Delay.msDelay( delay ); homeTimer.reset( ); pilot.forward( ); if ( homeTimer.elapsed( ) > returnHomeObstacleTime ) { pilot.stop( ); } } } } } public static void main( String[ ] args ) { int maximumTime = 120 * 1000; int returnHomeTime = 60 * 1000; int returnHomeObstacleTime = 2000; int delay = 500; boolean returnHomeBlind = true; int turnInterval = 20000; double wheelDiameter = 8.0; double vehicleTrack = 15.0; float initialHeading = 0.0f; float ultrasonicSensorOffsetX = 13.0f; float ultrasonicSensorOffsetY = 4.0f; int travelSpeed = 10; double minimumDistance = 20.0; double xMinimum = -90.0; double xMaximum = 90.0; double yMinimum = -90.0; double yMaximum = 90.0; double boundsTolerance = 10.0; int scoopRotationSpeed = 180; int perimeterLightLimit = 30; Motor.B.setSpeed( scoopRotationSpeed ); Motor.B.forward( ); OnNomNom omNomNom = new OnNomNom( ); omNomNom.pilot = new DifferentialPilot( wheelDiameter, vehicleTrack, Motor.A, Motor.C ); omNomNom.go( maximumTime, returnHomeTime, returnHomeObstacleTime, delay, returnHomeBlind, turnInterval, initialHeading, ultrasonicSensorOffsetX, ultrasonicSensorOffsetY, travelSpeed, minimumDistance, xMinimum, xMaximum, yMinimum, yMaximum, boundsTolerance, perimeterLightLimit ); }}